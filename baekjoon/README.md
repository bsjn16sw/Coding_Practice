## Contents
* [14501. 퇴사](#14501)
* [14502. 연구소](#14502)
* [14503. 로봇청소기](#14503)
* [14890. 경사로](#14890)
* [15685. 드래곤 커브](#15685)
* [17144. 미세먼지 안녕!](#17144)
* [14888. 연산자 끼워넣기](#14888)
* [17779. 게리맨더링2](#17779)
* [14889. 스타트와 링크](#14889)
* [14499. 주사위 굴리기](#14499)

<a name="14888"/>

## 14888. 연산자 끼워넣기
`void make_order()`  
DFS 기반으로 연산자 순열을 만든다. (같은 것을 포함하는 순열)  
현재까지 만든 연산자 순열의 길이인 `k`가 `N-1`이 되면 식을 계산하기 위해 `calc_formula()`를 호출하고 재귀함수를 종료한다. 아직 연산자 순열이 완성되지 않았다면 즉 `k < N-1`인 경우 재귀호출하여 순열을 연장한다. 각각 남은 더하기, 빼기, 곱하기, 나누기 개수를 의미하는 `a`, `s`, `m`, `d`를 차례로 확인해 순열의 `k`번째 자리에 해당 연산자를 넣는다. 단 `k`번째 자리에 같은 연산자를 두 번 이상 넣지 않기 때문에 중복되는 순열은 만들어지지 않는다.  
  
`void calc_formula()`  
완성된 연산자 순열과 입력으로 받은 숫자를 차례로 조합해 식을 계산한다.  
연산자 우선순위 없이 앞에서부터 차례로 계산하여 `tmp_result`에 저장한다. 전역변수인 `max_result`와 `min_result`에 최댓값, 최솟값을 저장한다.  
  
<a name="17779"/>

## 17779. 게리맨더링2
`int make_bound()`  
다이아몬드 모양의 5번 선거구 경계를 만든다. 경계는 `x`, `y`, `d1`, `d2`로 결정된다.  
먼저 `0 <= x <= N-3`, `1 <= y <= N-2`를 만족하는 `(x, y)`를 선택할 수 있다. 한 `(x, y)`에 대하여 가능한 최대의 `d1`은 `y`, `d2`는 `N-1-y`이다. 최대의 `d1`은 0열을 향해, 최대의 `d2`는 `N-1`열을 향해 대각선으로 나아가는 것이기 때문이다. 그 다음 `d1`을 1부터 `max_d1`까지 traverse하며 가능한 `d2`를 모두 조합한다. 단 이 때 하단 꼭짓점이 도시 범위를 넘어갈 수 있기 때문에, 하단 꼭짓점의 y좌표가 `N-1`일 때의 `d2`를 구하고 (`y-d1+d2 = N-1`) `max_d2`와 비교해 더 작은 값을 `d2`로 택한다. 이렇게 `x`, `y`, `d1`, `d2`이 결정되면 `calc_area()`를 호출한다. 그리고 리턴된 값 중 최솟값을 찾아 최종 리턴한다.  
<p align="center">
<img src="/baekjoon/img/17779-1.png" alt="17779-1" height="40%" width="40%" align="middle">
</p>
  

`int calc_area()`  
1번에서 5번 선거구의 인구 수를 구하고 최대 인구수와 최소 인구수의 차를 리턴한다.  
1번 선거구의 인구 수를 먼저 구해보자. 다이아몬드에서 1번 선거구 쪽 경계를 이루는 셀에 대하여 위쪽에 있는 셀은 모두 1번 선거구이다. 그림에서 노란색이 칠해져 있는 부분이다. 2번, 3번, 4번도 비슷한 방법으로 생각할 수 있으며 각각 오른쪽, 왼쪽, 아래쪽 셀이다. 그러나 이렇게 구역을 지정해도 남는 부분이 있다. 그림에서 빗금친 부분인데, 이 직사각형 모양을 각각의 선거구에 지정한다. 1번 선거구의 빗금친 부분의 경우 0행부터 `x+d1`행 전까지, 0열부터 `y-d1`열 전까지의 직사각형으로 생각할 수 있다.  
<p align="center">
<img src="/baekjoon/img/17779-2.png" alt="17779-2" height="40%" width="40%" align="middle">
</p>

<a name="14889"/>

## 14889. 스타트와 링크
`void make_team()`  
`N/2`명으로 구성된 팀을 만든다. **단 반대편 `N/2`명 팀도 자동으로 꾸려지므로 반대편 팀과 중복되지 않는 구성만 만든다.** 이를 위해 0번째 사람은 현재 만들고 있는 팀에 소속되어 있도록 한다. (초기 `mask`값이 1인 이유가 이것이다.)  
`mask`는 팀에 포함된 사람은 1, 포함되지 않은 사람은 0으로 처리된 비트마스크이다. DFS를 이용하여 `N/2`명의 팀을 꾸리고 `calc_diff()`를 호출한다.  

`void calc_diff()`  
인자로 받은 `mask`에 1로 표기된 팀을 스타트팀, 0으로 표기된 팀을 링크팀이라고 생각하고 각 팀의 시너지를 구해 차를 구한다. 링크팀의 시너지를 구하기 위해 `mask`, 스타트팀의 시너지를 구하기 위해 `~mask`를 인자로 하는 `make_pair()`를 각각 호출한다.  

`void make_pair()`  
`org_mask`에 0으로 표기된 팀에서 두 명씩 짝지은 페어들을 모두 구한다. 그리고 그 페어에 대하여 시너지를 더한다.  
예를 들어 `org_mask`(= 초기 `mask`)가 `111000`이었다고 하자. `make_pair()`는 0으로 표기된 팀에서 두 명씩 짝지은 페어를 DFS로 구한다. 예를 들어 `111110`에서 DFS는 리프에 도달하게 되며, 짝지은 페어만 1로 나타내기 위하여 `org_mask`와 `mask`를 XOR 처리한다. 즉 `111000` ^ `111110`은 `000110`이 된다. XOR의 결과에서 페어를 검출하고 시너지에 더해주게 된다. 이처럼 `org_mask`에서 0으로 표기된 팀의 시너지를 구하게 되므로 `calc_diff()`에서 `mask`에 대해 한 번, `~mask`에 대해 한 번 `make_pair()`를 호출한 것이다.  

  
<a name="14499"/>

## 14499. 주사위 굴리기
`void roll()`  
`move`값에 따라 동서남북 방향으로 이동한 좌표가 바운드를 넘어가지 않는지 확인하고, 바운드 내라면 주사위 전개도를 변경한다. 그리고 주사위 바닥과 주사위가 놓여있는 칸 사이에 값을 복사한다.  
**문제에 주어져있는 전개도 모양을 적극 활용한다.** 주사위가 동서남북 방향으로 이동하면 전개도가 어떻게 변경되는지 그려서 확인한 후 코드화한다. **동서남북 모든 경우에 대하여 주사위 네 면이 서로 교환되는데, 이 때 하나의 변수 `temp`만으로 해결할 수 있다.**  
<p align="center">
<img src="/baekjoon/img/14499.png" alt="14499" height="40%" width="40%" align="middle">
</p>

