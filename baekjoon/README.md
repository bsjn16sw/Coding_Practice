## Contents
* [14501. 퇴사](#14501)
* [14502. 연구소](#14502)
* [14503. 로봇청소기](#14503)
* [14890. 경사로](#14890)
* [15685. 드래곤 커브](#15685)
* [17144. 미세먼지 안녕!](#17144)
* [14888. 연산자 끼워넣기](#14888)
* [17779. 게리맨더링2](#17779)

<a name="14888"/>

## 14888. 연산자 끼워넣기
`void make_order()`  
DFS 기반으로 연산자 순열을 만든다. (같은 것을 포함하는 순열)  
현재까지 만든 연산자 순열의 길이인 `k`가 `N-1`이 되면 식을 계산하기 위해 `calc_formula()`를 호출하고 재귀함수를 종료한다. 아직 연산자 순열이 완성되지 않았다면 즉 `k < N-1`인 경우 재귀호출하여 순열을 연장한다. 각각 남은 더하기, 빼기, 곱하기, 나누기 개수를 의미하는 `a`, `s`, `m`, `d`를 차례로 확인해 순열의 `k`번째 자리에 해당 연산자를 넣는다. 단 `k`번째 자리에 같은 연산자를 두 번 이상 넣지 않기 때문에 중복되는 순열은 만들어지지 않는다.  
  
`void calc_formula()`  
완성된 연산자 순열과 입력으로 받은 숫자를 차례로 조합해 식을 계산한다.  
연산자 우선순위 없이 앞에서부터 차례로 계산하여 `tmp_result`에 저장한다. 전역변수인 `max_result`와 `min_result`에 최댓값, 최솟값을 저장한다.  
  
<a name="17779"/>

## 17779. 게리맨더링2
`int make_bound()`  
다이아몬드 모양의 5번 선거구 경계를 만든다. 경계는 `x`, `y`, `d1`, `d2`로 결정된다.  
먼저 `0 <= x <= N-3`, `1 <= y <= N-2`를 만족하는 `(x, y)`를 선택할 수 있다. 한 `(x, y)`에 대하여 가능한 최대의 `d1`은 `y`, `d2`는 `N-1-y`이다. 최대의 `d1`은 0열을 향해, 최대의 `d2`는 `N-1`열을 향해 대각선으로 나아가는 것이기 때문이다. 그 다음 `d1`을 1부터 `max_d1`까지 traverse하며 가능한 `d2`를 모두 조합한다. 단 이 때 하단 꼭짓점이 도시 범위를 넘어갈 수 있기 때문에, 하단 꼭짓점의 y좌표가 `N-1`일 때의 `d2`를 구하고 (`y-d1+d2 = N-1`) `max_d2`와 비교해 더 작은 값을 `d2`로 택한다. 이렇게 `x`, `y`, `d1`, `d2`이 결정되면 `calc_area()`를 호출한다. 그리고 리턴된 값 중 최솟값을 찾아 최종 리턴한다.  
<p align="center">
<img src="/baekjoon/img/17779-1.png" alt="17779-1" height="40%" width="40%" align="middle">
</p>
  

`int calc_area()`  
1~5번 선거구의 인구 수를 구하고 최대 인구수와 최소 인구수의 차를 리턴한다.  
1번 선거구의 인구 수를 먼저 구해보자. 다이아몬드에서 1번 선거구 쪽 경계를 이루는 셀에 대하여 위쪽에 있는 셀은 모두 1번 선거구이다. 그림에서 노란색이 칠해져 있는 부분이다. 2번, 3번, 4번도 비슷한 방법으로 생각할 수 있으며 각각 오른쪽, 왼쪽, 아래쪽 셀이다. 그러나 이렇게 구역을 지정해도 남는 부분이 있다. 그림에서 빗금친 부분인데, 이 직사각형 모양을 각각의 선거구에 지정한다. 1번 선거구의 빗금친 부분의 경우 0행부터 `x+d1`행 전까지, 0열부터 `y-d1`열 전까지의 직사각형으로 생각할 수 있다.  
<p align="center">
<img src="/baekjoon/img/17779-2.png" alt="17779-2" height="40%" width="40%" align="middle">
</p>
