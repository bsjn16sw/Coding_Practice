## Contents
* [14501. 퇴사](#14501)
* [14502. 연구소](#14502)
* [14503. 로봇청소기](#14503)
* [14890. 경사로](#14890)
* [15685. 드래곤 커브](#15685)
* [17144. 미세먼지 안녕!](#17144)
* [14888. 연산자 끼워넣기](#14888)
* [17779. 게리맨더링2](#17779)
* [14889. 스타트와 링크](#14889)
* [14499. 주사위 굴리기](#14499)
* [15686. 치킨 배달](#15686)
* [16234. 인구 이동](#16234)
* [15683. 감시](#15683)
* [14500. 테트로미노](#14500)
* [14891. 톱니바퀴](#14891)

<a name="14888"/>

## 14888. 연산자 끼워넣기
`void make_order()`  
DFS 기반으로 연산자 순열을 만든다. (같은 것을 포함하는 순열)  
현재까지 만든 연산자 순열의 길이인 `k`가 `N-1`이 되면 식을 계산하기 위해 `calc_formula()`를 호출하고 재귀함수를 종료한다. 아직 연산자 순열이 완성되지 않았다면 즉 `k < N-1`인 경우 재귀호출하여 순열을 연장한다. 각각 남은 더하기, 빼기, 곱하기, 나누기 개수를 의미하는 `a`, `s`, `m`, `d`를 차례로 확인해 순열의 `k`번째 자리에 해당 연산자를 넣는다. 단 `k`번째 자리에 같은 연산자를 두 번 이상 넣지 않기 때문에 중복되는 순열은 만들어지지 않는다.  
  
`void calc_formula()`  
완성된 연산자 순열과 입력으로 받은 숫자를 차례로 조합해 식을 계산한다.  
연산자 우선순위 없이 앞에서부터 차례로 계산하여 `tmp_result`에 저장한다. 전역변수인 `max_result`와 `min_result`에 최댓값, 최솟값을 저장한다.  
  
<a name="17779"/>

## 17779. 게리맨더링2
`int make_bound()`  
다이아몬드 모양의 5번 선거구 경계를 만든다. 경계는 `x`, `y`, `d1`, `d2`로 결정된다.  
먼저 `0 <= x <= N-3`, `1 <= y <= N-2`를 만족하는 `(x, y)`를 선택할 수 있다. 한 `(x, y)`에 대하여 가능한 최대의 `d1`은 `y`, `d2`는 `N-1-y`이다. 최대의 `d1`은 0열을 향해, 최대의 `d2`는 `N-1`열을 향해 대각선으로 나아가는 것이기 때문이다. 그 다음 `d1`을 1부터 `max_d1`까지 traverse하며 가능한 `d2`를 모두 조합한다. 단 이 때 하단 꼭짓점이 도시 범위를 넘어갈 수 있기 때문에, 하단 꼭짓점의 y좌표가 `N-1`일 때의 `d2`를 구하고 (`y-d1+d2 = N-1`) `max_d2`와 비교해 더 작은 값을 `d2`로 택한다. 이렇게 `x`, `y`, `d1`, `d2`이 결정되면 `calc_area()`를 호출한다. 그리고 리턴된 값 중 최솟값을 찾아 최종 리턴한다.  
<p align="center">
<img src="/baekjoon/img/17779-1.png" alt="17779-1" height="40%" width="40%" align="middle">
</p>
  

`int calc_area()`  
1번에서 5번 선거구의 인구 수를 구하고 최대 인구수와 최소 인구수의 차를 리턴한다.  
1번 선거구의 인구 수를 먼저 구해보자. 다이아몬드에서 1번 선거구 쪽 경계를 이루는 셀에 대하여 위쪽에 있는 셀은 모두 1번 선거구이다. 그림에서 노란색이 칠해져 있는 부분이다. 2번, 3번, 4번도 비슷한 방법으로 생각할 수 있으며 각각 오른쪽, 왼쪽, 아래쪽 셀이다. 그러나 이렇게 구역을 지정해도 남는 부분이 있다. 그림에서 빗금친 부분인데, 이 직사각형 모양을 각각의 선거구에 지정한다. 1번 선거구의 빗금친 부분의 경우 0행부터 `x+d1`행 전까지, 0열부터 `y-d1`열 전까지의 직사각형으로 생각할 수 있다.  
<p align="center">
<img src="/baekjoon/img/17779-2.png" alt="17779-2" height="40%" width="40%" align="middle">
</p>

<a name="14889"/>

## 14889. 스타트와 링크
`void make_team()`  
`N/2`명으로 구성된 팀을 만든다. **단 반대편 `N/2`명 팀도 자동으로 꾸려지므로 반대편 팀과 중복되지 않는 구성만 만든다.** 이를 위해 0번째 사람은 현재 만들고 있는 팀에 소속되어 있도록 한다. (초기 `mask`값이 1인 이유가 이것이다.)  
`mask`는 팀에 포함된 사람은 1, 포함되지 않은 사람은 0으로 처리된 비트마스크이다. DFS를 이용하여 `N/2`명의 팀을 꾸리고 `calc_diff()`를 호출한다.  

`void calc_diff()`  
인자로 받은 `mask`에 1로 표기된 팀을 스타트팀, 0으로 표기된 팀을 링크팀이라고 생각하고 각 팀의 시너지를 구해 차를 구한다. 링크팀의 시너지를 구하기 위해 `mask`, 스타트팀의 시너지를 구하기 위해 `~mask`를 인자로 하는 `make_pair()`를 각각 호출한다.  

`void make_pair()`  
`org_mask`에 0으로 표기된 팀에서 두 명씩 짝지은 페어들을 모두 구한다. 그리고 그 페어에 대하여 시너지를 더한다.  
예를 들어 `org_mask`(= 초기 `mask`)가 `111000`이었다고 하자. `make_pair()`는 0으로 표기된 팀에서 두 명씩 짝지은 페어를 DFS로 구한다. 예를 들어 `111110`에서 DFS는 리프에 도달하게 되며, 짝지은 페어만 1로 나타내기 위하여 `org_mask`와 `mask`를 XOR 처리한다. 즉 `111000` ^ `111110`은 `000110`이 된다. XOR의 결과에서 페어를 검출하고 시너지에 더해주게 된다. 이처럼 `org_mask`에서 0으로 표기된 팀의 시너지를 구하게 되므로 `calc_diff()`에서 `mask`에 대해 한 번, `~mask`에 대해 한 번 `make_pair()`를 호출한 것이다.  

  
<a name="14499"/>

## 14499. 주사위 굴리기
`void roll()`  
`move`값에 따라 동서남북 방향으로 이동한 좌표가 바운드를 넘어가지 않는지 확인하고, 바운드 내라면 주사위 전개도를 변경한다. 그리고 주사위 바닥과 주사위가 놓여있는 칸 사이에 값을 복사한다.  
**문제에 주어져있는 전개도 모양을 적극 활용한다.** 주사위가 동서남북 방향으로 이동하면 전개도가 어떻게 변경되는지 그려서 확인한 후 코드화한다. **동서남북 모든 경우에 대하여 주사위 네 면이 서로 교환되는데, 이 때 하나의 변수 `temp`만으로 해결할 수 있다.**  
<p align="center">
<img src="/baekjoon/img/14499.png" alt="14499" height="40%" width="40%" align="middle">
</p>

<a name="15686"/>

## 15686. 치킨 배달
처음 인풋을 받을 때 집과 치킨집의 좌표를 전역변수 `home`과 `chicken`에 저장했다. 그리고 집의 개수와 치킨집의 개수를 각각 `H`, `C`에 저장했다.  

`void select_chicken()`  
`C`개의 치킨집 중 `M`개의 치킨집을 고른다.  
비트마스크를 이용해 `C` combination `M`을 구했다. 단, 가령 13개의 치킨집 중 8개의 치킨집을 고른다면 5개를 골라 `mask`만 반대로 뒤집어주면 되기 때문에 `reverse` 인자를 두고 `C-M`개를 골라 `mask`를 뒤집을 것인지 그냥 `M`개를 골라 `mask`를 그대로 이용할 것인지를 알 수 있도록 하였다. 이 `reverse`가 있는 버전과 없는 버전을 비교했을 때 백준 저지에서는 4ms로 동일하게 나왔는데 `M`이 최대 13이기 때문에 큰 차이가 없는 것으로 추측된다. `M`이 큰 값이면 차이가 있을 것으로 예상된다. 이 과정을 통해 `mask`를 확정지으면 `calc_city_dist()`를 호출해 해당 `mask`에 대한 도시의 치킨 거리를 구한다.  

`int calc_city_dist()`  
도시의 치킨 거리를 구한다.  
도시의 치킨 거리는 각 집의 치킨 거리의 합과 같다. 그리고 각 집의 치킨 거리는 그 집과 `M`개의 치킨집까지의 치킨 거리의 최솟값과 같다. 따라서 `calc_home_dist()`를 이용해 각 집의 치킨 거리를 구한 다음 그것을 모두 더했다.  


`int calc_home_dist()`  
각 집의 치킨 거리를 구한다.  
`mask`에서 1인 인덱스를 가지는 `chicken`의 치킨집과 `h` 인덱스를 가지는 `home`의 집 사이의 거리를 모두 구해보고 최솟값을 반환하였다. 집과 치킨집 사이의 거리는 `calc_dist()`를 호출하여 계산하였다.  

`int calc_dist()`  
문제의 정의에 따라 두 위치 사이의 거리를 계산하였다.  

<a name="16234"/>

## 16234. 인구 이동
메인함수에서 `N`, `L`, `R`과 초기의 인구 배열을 `A`에 저장하였다. 그리고 인구 이동은 더 이상 인구 이동이 없을 때까지 (`move_flag`가 `false`일 때까지) 계속된다.  
한 차례의 인구 이동은 연합 번호를 저장하는 `B`와 연합 번호 별 각 나라의 새로운 인구를 저장하는 `C`를 각각 -1과 0으로 `memset()`하는 것 부터 시작한다. 이중 for문으로 직접 초기화하는 것보다 `memset()`을 이용하는 것이 실험 상 10ms 정도 빨랐다. `unite_num`도 0으로, `move_flag`도 `false`로 해준다.  
그리고 이중 for문을 돌면서 아직 연합을 이루지 않은 나라 즉 `B[i][j]`가 `-1`인 나라를 찾아 연합을 이루기 시작한다. `make_unite(i, j, unite_num);`을 호출하며, 이는 `unite_num`에 해당하는 전체 인구수와 나라수를 pair 형태로 반환한다. 만약 `nation`이 한 번이라도 2 이상이면 인구 이동이 일어나므로 `move_flag`를 `true`로 하였다. 연합 번호 별 각 나라의 새로운 인구수를 `C[unite_num]`에 저장하였다. `move_flag`가 `true`인 경우 이 `C`를 이용해 `A`를 바꿔줄 것이기 때문이다. **원래는 `C`를 사용하지 않고 대신 그 자리에 이중 for문을 넣어 연합 번호가 `unite_num`인 나라를 찾아 `people / nation`으로 `A[i][j]`를 바꿔주었었다. 이렇게 하면 최대 `unite_num`번 이중 for문을 돌려야 한다. 그러나 `C`를 이용함으로써 한 번만 이중 for문을 돌리게 하였다.** 한편 `unite_num`은 0부터 1씩 증가하는 숫자이며, 하나의 나라로도 이룰 수 있다고 보았다.  
연합을 모두 이루면 `move_flag`를 확인하였다. `false`인 경우 인구 이동이 일어나지 않으므로 `while(true)`를 `break`하였다. `true`인 경우는 최종 출력값인 `move`를 1 더하고 `B`와 `C`를 이용하여 `A`를 변경하였다. 이 부분이 위에서 강조한 이중 for문을 한 번만 돌리는 부분이다. 연합 번호 별로 그 연합에 속하는 나라의 좌표를 vector에 저장해보기도 했는데, 오히려 시간이 매우 오래 걸렸다.  

`pair<int, int> make_unite(int x, int y, int num)`  
`(x, y)` 나라를 연합 `num`에 할당하고 즉 `B[x][y] = num`으로 하고, `(x, y)`에서 사방으로 연합을 늘릴 수 있는지 확인한다. 연합 번호 `num`의 총 인구수와 나라수를 pair 형태로 반환한다.  
사방으로 연합을 늘릴 수 있는지 확인하는 것은 델타 배열 `dx`와 `dy`를 사용하였다. 그리고 `(x, y)`로 부터 한 칸 이동한 `(temp_x, temp_y)`가 연합을 이루기 적당한지 `valid_unite()`를 호출하여 확인하였다. 연합을 이룰 수 있다면 인구수와 나라수를 업데이트 해주었다.  

`bool valid_unite(int x, int y, int temp_x, int temp_y)`  
`(x, y)`에서 한 칸 확장된 `(temp_x, temp_y)`가 함께 연합을 이룰 수 있는지 확인한다.  
함께 연합을 이룰 수 있는 조건은 세 가지이다. 1) `(temp_x, temp_y)`의 인덱스가 valid하다. 2) `(temp_x, temp_y)`가 이미 다른 연합에 속해있지 않다. 3) `(x, y)`와 `(temp_x, temp_y)`의 인구수 차이가 L 이상 R 이하이다. 이 세 가지 조건을 모두 만족하는 경우에만 `true`를 반환한다.  

<a name="15683"/>

## 15683. 감시
메인함수에서 `map`에 `N` * `M`의 인풋을 저장했으며, CCTV는 구조체 `CCTV`의 전역 벡터인 `cctvs`에 저장하였다. 구조체 `CCTV`는 CCTV의 위치를 나타내는 `x`, `y`와 몇 번 CCTV인지 나타내는 `num`, CCTV를 90도로 회전한 가짓수 중 하나를 나타내는 `dir`을 멤버변수로 가진다.  

`void DFS(int k)`  
전체 CCTV에 대하여 90도로 회전한 가짓수 중 하나를 결정한다.  
`k`는 현재 새롭게 방향을 지정하려는 CCTV의 인덱스이다. CCTV의 `num`에 따라서 가능한 (회전하여 만들 수 있는) 가짓수가 다르므로 전역에 `possible_dirs`에 미리 그 가짓수를 저장해두었다. `possible_dirs`를 이용해 DFS로 모든 CCTV에 대하여 가짓수를 결정한다. 모두 결정했다면 `surveil()`을 호출한다.  

`void surveil()`  
각 CCTV의 `num`과 `dir`에 따라 오른쪽, 위쪽, 왼쪽, 아래쪽 중 감시하는 방향을 선택해 `surveil_1_dir()`을 호출한다. 단, 그 전에 `map2`에 `map`을 복사한다. 가령 1번 CCTV이고 오른쪽 방향을 감시한다면 `surveil_1_dir(x, y, RIGHT)`를 호출한다. `surveil_1_dir()`은 `map2`에 감시한 부분을 7로 변경한다. 따라서 `map2`에서 사각지대인 0인 부분의 개수를 세서 `min_blind`를 업데이트한다.  

`void surveil_1_dir(int x, int y, int dir)`  
`dir`이 `RIGHT`, `UP`, `LEFT`, `DOWN`이냐에 따라 해당 방향을 감시한다. 단, 벽이 있으면 해당 방향의 감시를 멈추며 CCTV가 있더라도 통과하여 그 부분도 감시한다고 생각한다. 감시한 부분은 `map2`에 7로 변경한다.  

<a name="14500"/>

## 14500. 테트로미노
5가지 테트로미노를 회전/대칭하여 만들 수 있는 가짓수는 총 19가지이다. 1가지 모양에 대해, 내부 4개의 셀을 델타 배열처럼 표현하였다. 가령 □□□□ 모양이라면 맨 처음 셀을 기준으로 하면 (0, 0), (0, 1), (0, 2), (0, 3)이므로 dx = {0, 0, 0, 0}, dy = {0, 1, 2, 3}처럼 표현하였다. 19가지에 대하 모두 이렇게 표현하여 2차원 배열로 묶은 것이 `dx`와 `dy`이다.  
`N` * `M`의 종이 위 모든 셀을 기준으로 해 다음을 수행하였다.  
19가지의 모양 중 1가지에 대하여  
1) 4개의 셀이 모두 종이 위에 표현될 수 있는가? (인덱스)  
2) 만약 그렇다면 합을 계산하고, 최댓값을 갱신한다.  

<p align="center">
<img src="/baekjoon/img/14500.png" alt="14500" height="40%" width="40%" align="middle">
</p>

<a name="14891"/>

## 14891. 톱니바퀴
톱니바퀴 정보가 띄어쓰기로 분리되어 있지 않으므로, 한 톱니바퀴에 대하여 스트링으로 받고 하나씩 파싱해 전역 `cogwheel`에 넣어주었다. 회전 정보를 받을 때마다 `rotate_check()`를 호출했다. 단 인풋으로 주어지는 톱니바퀴 번호는 1부터 시작하고, 코드에서는 0부터 시작했으므로 -1 해서 인자로 넘겨주었다.  

`void rotate_check(int cog, int cw)`  
회전시킬 톱니바퀴 번호 `cog`와 회전 방향 `cw`의 pair를 원소로 하는 queue `q`에 적절히 enque하고, enque가 끝나면 deque해가며 `rotate()`를 호출하였다.  
먼저 처음 인자로 들어왔던 `cog`와 `cw`의 페어를 먼저 `q`에 enque하였다. 그리고 `cog`보다 오른쪽 방향에 있는 톱니바퀴를 회전해야 하는지 확인하였다. 회전해야 한다면 회전시킬 톱니바퀴 번호와 직전에 회전시켰던 방향의 반대방향의 페어를 `q`에 enque하였다. 회전하지 않는다면 `break`하여 그 방향의 톱니바퀴는 더 이상 확인하지 않았다. 왼쪽 방향도 마찬가지로 진행하였다. enque 과정이 모두 끝나면 `!q.empty()`할 때까지 하나씩 deque해가며 `rotate()`를 호출해 실제로 회전시켰다.  

`void rotate(int cog, ing cw)`  
`cog`번째 톱니바퀴를 `cw` 방향으로 회전시킨 결과를 전역 `cogwheel`에 적용하였다. 단 회전시킬 때 직전 결과를 덮어쓰지 않도록 주의한다. 틀린 버전은 아래 *실수했던 부분*의 5)를 참고.  

`int calc_score()`  
회전이 모두 끝나고 모든 톱니바퀴에 대하여 12시 방향의 극을 확인하였다. S극이라면 `pow(2, i)`를 `score`에 더해주었다. for문에 간편하게 넣어주기 위해 `pow()`를 활용했다.  

*실수했던 부분*
1) 처음 인풋 받을 때 톱니바퀴 정보가 띄어쓰기로 분리되어 있지 않아서 스트링으로 받고 하나씩 파싱해주어야 했는데, 띄어쓰기로 분리되어 있지 않다는 것 자체를 생각을 못해서 시간을 많이 낭비했다. 스트링으로 한 톱니바퀴의 정보를 받은 다음, 스트링을 traverse 하면서 하나씩 얻어오고 '0'을 빼주는 것까지 해야 한다. 스트링을 파싱하면 char이기 때문이다. 
2) 인풋으로 주어지는 톱니바퀴 번호는 1부터 시작하고, 코드에서는 0부터 시작했으므로 -1 해서 `rotate_check()`의 인자로 넘겨주었어야 하는데 이걸 생각 못하고 그냥 넘겨줬었다.  
3) 양옆 방향 톱니바퀴를 회전해야 하는지 확인하고 회전해야 한다면 톱니바퀴 번호와 방향을 `q`에 enque 해주었는데, 회전 방향이 계속 반대가 되야 한다는 것을 적용해주지 않았었다. (그냥 인풋에 주어진 회전 방향의 반대 방향을 여러 톱니바퀴 회전에 그대로 적용했다.) 문제를 꼼꼼히 읽어야한다!  
4) 주변 톱니바퀴 회전 정보는 enque 해주었는데 막상 자기 자신의 회전 정보를 enque 해주지 않았다. 빼먹는 부분 없이 하자.  
5) `rotate()`에서 반시계 방향 회전은 문제가 없었는데 시계 방향 회전에서 값을 계속 덮어 써서 버그가 있었다. 회전 시 주의해야한다.   
```cpp
// 틀린 버전
for(int i=0; i<7; i++)
    cogwheel[cog][i+1] = cogwheel[cog][i];

// 맞는 버전
for(int i=6; i>=0; i--)
    cogwheel[cog][i+1] = cogwheel[cog][i];
```
6) queue에서 `q.pop()`은 아무것도 반환하지 않는다. 얻어오면서 pop도 하고 싶다면 `q.front()`로 받은 다음 `q.pop()`을 해주어야 한다.  